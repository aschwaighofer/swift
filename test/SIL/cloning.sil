// RUN: %target-sil-opt -enable-sil-verify-all -inline %s | FileCheck %s

// Check cloning of instructions.

sil_stage canonical

import Builtin

class X {
}

sil @takes_int64_float64 : $@convention(thin) (Builtin.Int64, Builtin.FPIEEE64) -> ()

sil [always_inline] @callee_alloc_ref_stack : $@convention(thin) () -> () {
bb0:
  %0 = float_literal $Builtin.FPIEEE64, 0x402E4CCCCCCCCCCD
  %1 = alloc_ref [stack] $X
  dealloc_ref [stack] %1 : $X
  %2 = function_ref @takes_int64_float64 : $@convention(thin) (Builtin.Int64, Builtin.FPIEEE64) -> ()
  %3 = partial_apply [stack] %2(%0) : $@convention(thin) (Builtin.Int64, Builtin.FPIEEE64) -> ()
  strong_release %3 : $@callee_owned (Builtin.Int64) -> ()
  dealloc_ref [stack] %3: $@callee_owned (Int) -> ()
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @caller_alloc_ref_stack : $@convention(thin) () -> ()
// CHECK: [[X:%[0-9]+]] = alloc_ref [stack] $X
// CHECK: dealloc_ref [stack] [[X]] : $X
// CHECK: partial_apply [stack]
// CHECK: return
sil @caller_alloc_ref_stack : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @callee_alloc_ref_stack : $@convention(thin) () -> ()
  %1 = apply %0() : $@convention(thin) () -> ()
  %2 = tuple ()
  return %2 : $()
}

