#define DEBUG_TYPE "opaque-archetype-specializer"

#include "swift/SIL/SILFunction.h"
#include "swift/SIL/TypeSubstCloner.h"
#include "swift/SIL/SILInstruction.h"
#include "swift/SILOptimizer/PassManager/Transforms.h"
#include "swift/SILOptimizer/Utils/CFG.h"


using namespace swift;

namespace {
class OpaqueSpecializerCloner
    : public TypeSubstCloner<OpaqueSpecializerCloner,
                      SILOptFunctionBuilder /*unused*/> {

  using SuperTy =
      TypeSubstCloner<OpaqueSpecializerCloner, SILOptFunctionBuilder>;

  SILBasicBlock *entryBlock;
  SILBasicBlock *cloneFromBlock;

public:
  friend class SILCloner<OpaqueSpecializerCloner>;
  friend class SILInstructionVisitor<OpaqueSpecializerCloner>;

  OpaqueSpecializerCloner(SubstitutionMap opaqueArchetypeSubs, SILFunction &fun)
      : SuperTy(fun, fun, opaqueArchetypeSubs) {
    entryBlock = fun.getEntryBlock();
    cloneFromBlock = entryBlock->split(entryBlock->begin());
  }

  void clone();

protected:
  void insertOpaqueToConcreteAddressCasts(SILInstruction *orig,
                                          SILInstruction *cloned);

  void postProcess(SILInstruction *orig, SILInstruction *cloned) {
    SILClonerWithScopes<OpaqueSpecializerCloner>::postProcess(orig, cloned);
    insertOpaqueToConcreteAddressCasts(orig, cloned);
  }

  void visitTerminator(SILBasicBlock *BB) {
    visit(BB->getTerminator());
  }

  void visitReturnInst(ReturnInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    auto origResult = Inst->getOperand();
    auto clonedResult = getOpValue(Inst->getOperand());
    if (clonedResult->getType().getASTType() != origResult->getType().getASTType())
      clonedResult = getBuilder().createUncheckedRefCast(
          RegularLocation::getAutoGeneratedLocation(), clonedResult,
          origResult->getType());
    recordClonedInstruction(
        Inst,
        getBuilder().createReturn(getOpLocation(Inst->getLoc()), clonedResult));
  }

  /// Projections should not change the type.
  void visitStructElementAddrInst(StructElementAddrInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(Inst, getBuilder().createStructElementAddr(
                                      getOpLocation(Inst->getLoc()),
                                      getOpValue(Inst->getOperand()),
                                      Inst->getField(), Inst->getType()));
  }
  /// Projections should not change the type.
  void visitStructExtractInst(StructExtractInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(
        Inst, getBuilder().createStructExtract(
                  getOpLocation(Inst->getLoc()), getOpValue(Inst->getOperand()),
                  Inst->getField(), Inst->getType()));
  }
  /// Projections should not change the type.
  void visitTupleElementAddrInst(TupleElementAddrInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(Inst, getBuilder().createTupleElementAddr(
                                      getOpLocation(Inst->getLoc()),
                                      getOpValue(Inst->getOperand()),
                                      Inst->getFieldNo(), Inst->getType()));
  }
  /// Projections should not change the type.
  void visitTupleExtractInst(TupleExtractInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(
        Inst, getBuilder().createTupleExtract(
                  getOpLocation(Inst->getLoc()), getOpValue(Inst->getOperand()),
                  Inst->getFieldNo(), Inst->getType()));
  }
  /// Projections should not change the type.
  void visitRefElementAddrInst(RefElementAddrInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(
        Inst, getBuilder().createRefElementAddr(
                  getOpLocation(Inst->getLoc()), getOpValue(Inst->getOperand()),
                  Inst->getField(), Inst->getType()));
  }
  /// Projections should not change the type.
  void visitRefTailAddrInst(RefTailAddrInst *Inst) {
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(
        Inst, getBuilder().createRefTailAddr(getOpLocation(Inst->getLoc()),
                                             getOpValue(Inst->getOperand()),
                                             Inst->getType()));
  }

  void visitYieldInst(YieldInst *Inst) {
    auto OrigValues = Inst->getYieldedValues();
    auto Values = getOpValueArray<8>(Inst->getYieldedValues());
    auto ResumeBB = getOpBasicBlock(Inst->getResumeBB());
    auto UnwindBB = getOpBasicBlock(Inst->getUnwindBB());
    for (auto idx : indices(Values)) {
      if (OrigValues[idx]->getType().getASTType() !=
          Values[idx]->getType().getASTType()) {
        if (!Values[idx]->getType().isAddress()) {
          Values[idx] = getBuilder().createUncheckedRefCast(
              RegularLocation::getAutoGeneratedLocation(), Values[idx],
              OrigValues[idx]->getType());
        } else {
          Values[idx] = getBuilder().createUncheckedAddrCast(
              RegularLocation::getAutoGeneratedLocation(), Values[idx],
              OrigValues[idx]->getType());
        }
      }
    }

    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    recordClonedInstruction(
        Inst, getBuilder().createYield(getOpLocation(Inst->getLoc()), Values,
                                       ResumeBB, UnwindBB));
  }

  void visitCopyAddrInst(CopyAddrInst *Inst) {
    auto src = getOpValue(Inst->getSrc());
    auto dst = getOpValue(Inst->getDest());
    auto srcType = src->getType();
    auto destType = dst->getType();
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    // If the types mismatch cast the operands to the non opaque archetype.
    if (destType.getASTType() != srcType.getASTType()) {
      if (srcType.getASTType()->hasOpaqueArchetype()) {
        src = getBuilder().createUncheckedAddrCast(
            getOpLocation(Inst->getLoc()), src, destType);
      } else if (destType.getASTType()->hasOpaqueArchetype()) {
        dst = getBuilder().createUncheckedAddrCast(
            getOpLocation(Inst->getLoc()), dst, srcType);
      }
    }
    recordClonedInstruction(
        Inst, getBuilder().createCopyAddr(getOpLocation(Inst->getLoc()), src,
                                          dst, Inst->isTakeOfSrc(),
                                          Inst->isInitializationOfDest()));
  }

  void visitStoreInst(StoreInst *Inst) {
    auto src = getOpValue(Inst->getSrc());
    auto dst = getOpValue(Inst->getDest());
    auto srcType = src->getType();
    auto destType = dst->getType();
    getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));
    // If the types mismatch cast the operands to the non opaque archetype.
    if (destType.getASTType() != srcType.getASTType()) {
      if (srcType.getASTType()->hasOpaqueArchetype()) {
        assert(!srcType.isAddress());
        src = getBuilder().createUncheckedRefCast(
            getOpLocation(Inst->getLoc()), src, destType);
      } else if (destType.getASTType()->hasOpaqueArchetype()) {
        dst = getBuilder().createUncheckedAddrCast(
            getOpLocation(Inst->getLoc()), dst, srcType.getAddressType());
      }
    }

    if (!getBuilder().hasOwnership()) {
      switch (Inst->getOwnershipQualifier()) {
      case StoreOwnershipQualifier::Assign: {
        auto *li = getBuilder().createLoad(getOpLocation(Inst->getLoc()), dst,
                                           LoadOwnershipQualifier::Unqualified);
        auto *si = getBuilder().createStore(
            getOpLocation(Inst->getLoc()), src, getOpValue(Inst->getDest()),
            StoreOwnershipQualifier::Unqualified);
        getBuilder().emitDestroyValueOperation(getOpLocation(Inst->getLoc()),
                                               li);
        return recordClonedInstruction(Inst, si);
      }
      case StoreOwnershipQualifier::Init:
      case StoreOwnershipQualifier::Trivial:
      case StoreOwnershipQualifier::Unqualified:
        break;
      }

      return recordClonedInstruction(
          Inst,
          getBuilder().createStore(getOpLocation(Inst->getLoc()), src, dst,
                                   StoreOwnershipQualifier::Unqualified));
    }

    recordClonedInstruction(
        Inst, getBuilder().createStore(getOpLocation(Inst->getLoc()), src, dst,
                                       Inst->getOwnershipQualifier()));
  }

protected:
  SILType remapType(SILType Ty) {
    SILType &Sty = TypeCache[Ty];
    if (!Sty) {
      // Apply the opaque types substitution.
      ReplaceOpaqueTypesWithUnderlyingTypes replacer;
      Sty = Ty.subst(Original.getModule(), SubsMap)
                .subst(Original.getModule(), replacer, replacer,
                       CanGenericSignature(), true);
    }
    return Sty;
  }

  CanType remapASTType(CanType ty) {
    // Apply the opaque types substitution.
    ReplaceOpaqueTypesWithUnderlyingTypes replacer;
    return SuperTy::remapASTType(ty)
        .subst(replacer, replacer,
               SubstFlags::SubstituteOpaqueArchetypes |
                   SubstFlags::AllowLoweredTypes)
        ->getCanonicalType();
  }

  ProtocolConformanceRef remapConformance(Type type,
                                          ProtocolConformanceRef conf) {
    // Apply the opaque types substitution.
    ReplaceOpaqueTypesWithUnderlyingTypes replacer;
    return SuperTy::remapConformance(type, conf)
        .subst(type, replacer, replacer,
               SubstFlags::SubstituteOpaqueArchetypes |
                   SubstFlags::AllowLoweredTypes);
  }

  SubstitutionMap remapSubstitutionMap(SubstitutionMap Subs) {
    // Apply the opaque types substitution.
    ReplaceOpaqueTypesWithUnderlyingTypes replacer;
    return SuperTy::remapSubstitutionMap(Subs).subst(
        replacer, replacer,
        SubstFlags::SubstituteOpaqueArchetypes | SubstFlags::AllowLoweredTypes);
  }
};
} // namespace

void OpaqueSpecializerCloner::clone() {
  for (auto arg: entryBlock->getArguments())
    recordFoldedValue(arg, arg);
  cloneReachableBlocks(cloneFromBlock, {}, entryBlock,
                       true /*havePrepopulatedFunctionArgs*/);
  getBuilder().setInsertionPoint(entryBlock);
  getBuilder().createBranch(RegularLocation::getAutoGeneratedLocation(),
                            getOpBasicBlock(cloneFromBlock));
}

/// Update address uses of the opaque type archetype with the concrete type.
/// This is neccessary for apply instructions.
void OpaqueSpecializerCloner::insertOpaqueToConcreteAddressCasts(
    SILInstruction *orig, SILInstruction *cloned) {

  // Replace apply operands.
  if (auto apply = ApplySite::isa(cloned)) {
    SavedInsertionPointRAII restore(getBuilder());
    getBuilder().setInsertionPoint(apply.getInstruction());
    auto substConv = apply.getSubstCalleeConv();
    unsigned idx = 0;
    for (auto &opd : apply.getArgumentOperands()) {
      auto argConv = apply.getArgumentConvention(opd);
      auto argIdx = apply.getCalleeArgIndex(opd);
      auto argType = substConv.getSILArgumentType(argIdx);
      if (argType.getASTType() != opd.get()->getType().getASTType()) {
        if (argConv.isIndirectConvention()) {
          auto cast = getBuilder().createUncheckedAddrCast(apply.getLoc(),
                                                           opd.get(), argType);
          opd.set(cast);
        } else {
          auto cast = getBuilder().createUncheckedRefCast(apply.getLoc(),
                                                          opd.get(), argType);
          opd.set(cast);
        }
      }
      ++idx;
    }
    return;
  }
}

namespace {
class OpaqueArchetypeSpecializer : public SILFunctionTransform {
  void run() override {

    // Look for opaque type archetypes.
    bool foundOpaqueArchetype = false;
    for (auto &BB : *getFunction()) {
      for (auto &inst : BB) {
        for (auto &opd : inst.getAllOperands()) {
          if (!opd.get()->getType().getASTType()->hasOpaqueArchetype())
            continue;
          foundOpaqueArchetype = true;
          break;
        }
        if (foundOpaqueArchetype)
          break;
        auto *allocStack = dyn_cast<AllocStackInst>(&inst);
        if (!allocStack ||
            !allocStack->getElementType().getASTType()->hasOpaqueArchetype())
          continue;
        foundOpaqueArchetype = true;
        break;
      }
    }

    if (foundOpaqueArchetype) {
      SubstitutionMap subsMap = getFunction()->getForwardingSubstitutionMap();
      OpaqueSpecializerCloner s(subsMap, *getFunction());
      s.clone();
      removeUnreachableBlocks(*getFunction());
    }

    if (foundOpaqueArchetype)
      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);
  }
};
} // end anonymous namespace

SILTransform *swift::createOpaqueArchetypeSpecializer() {
  return new OpaqueArchetypeSpecializer();
}
